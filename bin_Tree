/*
    class Node 
    	int data;
    	Node left;
    	Node right;
	*/
 /*
 The height of a binary tree is the number of edges between the tree's root and its furthest leaf.
 */
	public static int height(Node root) {
      	// Write your code here.
        // Base case: if the tree is empty, the height is 0
        if (root == null) {
            return -1;
        }
        // Recursively calculate the height of left and right subtrees
        int leftHeight = height(root.left);
        int rightHeight = height(root.right);

        // Height of the current node is max of heights of its subtrees plus 1
        return Math.max(leftHeight, rightHeight) + 1;
    }

//__________________________________________________________________________________________//
For example :

   1
    \
     2
      \
       5
      /  \
     3    6
      \
       4
Top View : 1, 2, 5, 6.

public static void topView(Node root) {
        Map<Integer, Integer> topView = new TreeMap<>(); // TreeMap to keep it sorted by keys

        Queue<AbstractMap.SimpleEntry<Integer, Node>> queue = new ArrayDeque<>();

        queue.add(new AbstractMap.SimpleEntry<>(0, root));

        while (!queue.isEmpty()) {
            AbstractMap.SimpleEntry<Integer, Node> currentEntry = queue.poll();

            Integer horizontalDistance = currentEntry.getKey();
            Node currentNode = currentEntry.getValue();

            // Insert the node into the top view map if the key is not already present
            if (!topView.containsKey(horizontalDistance)) {
                topView.put(horizontalDistance, currentNode.data);
            }

            // Add the left child with a horizontal distance decreased by 1
            if (currentNode.left != null) {
                queue.add(new AbstractMap.SimpleEntry<>(horizontalDistance - 1, currentNode.left));
            }

            // Add the right child with a horizontal distance increased by 1
            if (currentNode.right != null) {
                queue.add(new AbstractMap.SimpleEntry<>(horizontalDistance + 1, currentNode.right));
            }
        }

        // Print the top view
        for (int hd : topView.keySet()) {
            System.out.print(topView.get(hd) + " ");
        }

    }

//__________________________________________________________________________________________//

 	1
       / \
      2   3
     / \ / \
    4  5 6  7		It should output the nodes in the following order: 1 2 3 4 5 6 7.

Given a pointer to the root of a binary tree, you need to print the level order traversal of this tree. 
In level-order traversal (also known as breadth-first traversal)., nodes are visited level by level from left to right.

// Function to perform level-order traversal of the binary tree
    public static void levelOrder(Node root) {
        if (root == null) {
            return;
        }

        // Create a queue for level-order traversal
        Queue<Node> queue = new LinkedList<>();
        queue.add(root);

        while (!queue.isEmpty()) {
            // Remove the front node from the queue and print its data
            Node currentNode = queue.poll();
            System.out.print(currentNode.data + " ");

            // Add the left child to the queue
            if (currentNode.left != null) {
                queue.add(currentNode.left);
            }

            // Add the right child to the queue
            if (currentNode.right != null) {
                queue.add(currentNode.right);
            }
        }
    }

//__________________________________________________________________________________________//
/*
You are given a pointer to the root of a binary search tree and values to be inserted into the tree. 
Insert the values into their appropriate position in the binary search tree and return the root of the updated binary tree. 
*/

public static Node insert(Node root,int data) {
        if(root == null)
            return new Node(data);
    	 // Otherwise, recur down the tree
        if (data < root.data) {
            root.left = insert(root.left, data);
        } else if (data > root.data) {
            root.right = insert(root.right, data);
        }

        // Return the (unchanged) root pointer
        return root;
    }

